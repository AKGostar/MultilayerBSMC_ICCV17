classdef Moseg < handle
    % This class follows the strategy design pattern.
    properties
        % Model
        Options = moseg.MosegOptions;
        CurrState;
        MaxLbl = 0;
        
        % View
        Highlight;
        
        TimingStats;
    end
    
    properties(Transient=true)
        PrevState;        
        MosegAlg;
    end
    
    
    methods
        function obj = Moseg(mosegAlg, opt)
            if (nargin > 1)
                obj.Options = opt;
            end

            obj.CurrState.len = zeros(1,0);
            obj.CurrState.points = nan(2*obj.Options.buffSize,0);
            obj.CurrState.trajIds = [];
            obj.CurrState.trackno = [];
            obj.CurrState.lbls = [];
            obj.CurrState.maxTrajId = 0;
            obj.CurrState.startFrame = [];
            obj.CurrState.endFrame = [];
            obj.CurrState.frameNo = 0;
            obj.CurrState.compTime = 0;
            obj.CurrState.totalTime = 0;
            obj.CurrState.bgclust = [];
            obj.CurrState.memTrajIds = []; %%% add by ethan 10/13

            obj.MosegAlg = mosegAlg;
            
        end
        
%         function lookahead(obj, points, trackno)
%             % Extends trajectories without advancing state
%             obj.stepInit();
%             obj.stepTraj(points, trackno);
%             
%             %fprintf('Moseg: Tracks = %d\n', size(obj.CurrState.points,2)); 
%             assert(size(obj.CurrState.points,2) == length(obj.CurrState.trajIds));
%             
%             tid = tic;
%             % Use the set of points that span the entire window.
%             obj.CurrState.lbls = zeros(1,size(obj.CurrState.points,2));
%             
%             obj.CurrState.compTime = toc(tid);
%             obj.CurrState.totalTime = obj.CurrState.totalTime + obj.CurrState.compTime;
%         end
        
        function step(obj, points, trackno)
            obj.stepInit();
            obj.stepTraj(points, trackno);
            assert(size(obj.CurrState.points,2) == length(obj.CurrState.trajIds));
            
            tid = tic;
            % Use the set of points that span the entire window.
            % the main process, the main reason of time-consuming 
            obj.CurrState.lbls = obj.MosegAlg.step(obj.CurrState.points, ...
                obj.CurrState.trajIds, ...
                obj.CurrState.trackno, ...
                obj.CurrState.len, ...
                obj.CurrState.frameNo);
            
            M = mode(obj.CurrState.lbls(:));

            if M ~= 0 && isempty(obj.CurrState.bgclust)
                obj.CurrState.bgclust = M;
                fprintf('\n##### Decide the bglabel is %d\n',  obj.CurrState.bgclust);
            elseif( M ~= 0 && ~isempty(obj.CurrState.bgclust))
                bg_ratio = sum(obj.CurrState.lbls(:) == obj.CurrState.bgclust)/numel(obj.CurrState.lbls);
                if bg_ratio < 0.05
                    fprintf('\n##### Switch the bglabel from %d to %d\n',  obj.CurrState.bgclust, M);
                    obj.CurrState.bgclust = M;
                end
            end
            obj.CurrState.compTime = toc(tid);
            obj.CurrState.totalTime = obj.CurrState.totalTime + obj.CurrState.compTime;
        end
        
%         function visualize(obj, alggt)
%             if (nargin < 2)
%                 obj.MosegAlg.visualize();
%             else
%                 % Get ground truth labels
%                 gtlbls = alggt.step(obj.CurrState.points, ...
%                     obj.CurrState.trajIds, ...
%                     obj.CurrState.trackno, ...
%                     obj.CurrState.len, ...
%                     obj.CurrState.frameNo);
% 
%                 obj.MosegAlg.visualize(obj.CurrState.trajIds, gtlbls);
%             end
%         end
%         
%         function visualizeAff(obj)
%             obj.MosegAlg.visualizeAff(obj.CurrState.points, obj.CurrState.trajIds);
%         end
        
%         function plottracks(obj, labeledonly)
%             if (nargin < 2); labeledonly = true; end
%             hold on;
%             lbls = obj.CurrState.lbls;
%             points = obj.CurrState.points;            
%             colors = [0 0 0; moseg.MosegUtils.gencolormap(false)];
%             caxis(gca, [0 size(colors,1)]);
%             if (labeledonly)
%                 scatter(points(1,lbls > 0),points(2,lbls>0),20,colors(lbls(lbls>0)+1,:));
%             else
%                 scatter(points(1,:),points(2,:),20,colors(lbls+1,:),'filled');            
%             end
% 
%             %             for i=1:size(obj.CurrState.points,2)
% %                 len = min(obj.CurrState.len(i), obj.Options.buffSize);
% %                 plot(obj.CurrState.points(1:2:(2*len),i) , obj.CurrState.points(2:2:(2*len),i), '-', 'Color', cmap(lbls(i)+1,:));
% %             end
%         end
                        
%         function outim = genim(obj, im, useim, varargin)
%             if (nargin < 3)
%                 useim = false;
%             end
%             
%             if (useim)
%                 outim = im;
%             else
%                 outim = uint8(repmat(255, size(im)));
%             end
%             
%             lookahead = 0;
%             for i=1:2:length(varargin)
%                 switch(varargin{i})
%                     case 'LookAhead'
%                         lookahead = varargin{i+1};                        
%                     otherwise
%                         error('Unknown parameter name %s', varargin{i});
%                 end
%             end
%             
%             colors = moseg.MosegUtils.gencolormap(true);
%             colors = [0 0 0; colors];
%             
%             % Assumes all points in Alg are passed
%             lbls = obj.CurrState.lbls;
%             % Assumes all points in Alg are passed
%             mempoints = obj.CurrState.points(2*lookahead + (1:2),:);
%             mempoints = mempoints(:, lbls ~=0);
%             lbls = lbls(lbls ~= 0);
%             if (size(lbls,1) ~= 1)
%                 lbls = lbls';
%             end
% 
%             if (isempty(lbls))
%                 return;
%             end
% 
%             % Create an image of white values
% 
%             hm = vision.MarkerInserter;
%             %outim = im;
%             for i=unique(lbls);
%                 points = round(mempoints(1:2, lbls == i));
%                 hm.Shape = 'Square';
%                 hm.Fill = true;                
%                 %hm.Fill = true;
%                 if ((strcmp(hm.Shape, 'Square') || strcmp(hm.Shape, 'Circle')) && ...
%                         hm.Fill == true)
%                     hm.FillColor = 'Custom';
%                     hm.CustomFillColor = colors(i+1,:);
%                 else
%                     hm.BorderColor = 'Custom';
%                     hm.CustomBorderColor = colors(i+1,:);
%                 end
%                 hm.Size = 1;
%                 hm.Opacity = 1;
%               %%%  if (strcmp(version('-release'),'2011b'))
%                     outim = step(hm, outim, int16(points'));
%               %%%  else
%               %%%      outim = step(hm, outim, int16(points([2 1],:) - 1));                    
%               %%%  end
%                 release(hm);                            
%             end
%         end        
        
%         function highlightpair(obj, src, eventdata)
%             delete(obj.Highlight);
%             disp(eventdata.t1);
%             disp(eventdata.t2);
%             % Find locations of the trajIds
%             i1 = find(obj.CurrState.trajIds == eventdata.t1);
%             i2 = find(obj.CurrState.trajIds == eventdata.t2);
%             p1 = obj.CurrState.points(1:2, i1); 
%             p2 = obj.CurrState.points(1:2, i2);
%             disp(p1');
%             disp(p2');
%             figure(1);
%             hold on;
%             obj.Highlight = plot([p1(1) p2(1)], [p1(2) p2(2)], 'k+');
%         end
        
        function printStats(obj)
            s = fieldnames(obj.MosegAlg.TimingStats);
            if (~isempty(s))
                for i=1:length(s)-1
                    fprintf('%s: %f, ', s{i}, obj.MosegAlg.TimingStats.(s{i}));
                end
                fprintf('%s: %f\n', s{end}, obj.MosegAlg.TimingStats.(s{end}));                
            end
        end
%         
%         function [tid, p, len, lbl] = getTrajInfo(obj, point)
%             if (size(point,1) ==1)
%                 point = point';
%             end
%             % Find the trajectory closest
%             [mask,loc] = ismember(obj.MosegAlg.CurrState.memTrajIds, obj.CurrState.trajIds);
%             d = sum(bsxfun(@minus, obj.CurrState.points(1:2,loc(mask)), point).^2);
%             [~,ix] = min(d);
%             ix = loc(ix);
%             tid = obj.CurrState.trajIds(ix);
%             p = obj.CurrState.points(1:2, ix);
%             len = obj.CurrState.len(ix);
%             lbl = obj.CurrState.lbls(ix);
%         end
        
    end
    
    methods (Access = private)
        function stepInit(obj)
            obj.PrevState = obj.CurrState;
            obj.CurrState = struct;
            obj.CurrState.len = zeros(1,0);
            obj.CurrState.points = nan(2*obj.Options.buffSize,0);
            obj.CurrState.trajIds = [];
            obj.CurrState.lbls = [];
            obj.CurrState.trackno = [];
            obj.CurrState.maxTrajId = 0;
            obj.CurrState.frameNo = obj.PrevState.frameNo + 1;
            obj.CurrState.compTime = 0;
            obj.CurrState.totalTime = obj.PrevState.totalTime;
            obj.CurrState.bgclust = obj.PrevState.bgclust;
            %obj.CurrState.frame = frame;

            if (obj.Options.extrads)
                obj.CurrState.startFrame = [];
                obj.CurrState.endFrame = [];
            end
        end
        
        function stepTraj(obj, dpoints, trackno)
            
            %%% Match points to previous frame
            if (obj.PrevState.maxTrajId > 0)
                [~,ia,ib] = intersect(trackno, obj.PrevState.trackno);
                tracked = false(size(obj.PrevState.points,2),1);
                tracked(ib) = 1;
                points = nan(2,size(obj.PrevState.points,2));
                points(:,ib) = dpoints(:,ia);

                points = [ points ; obj.PrevState.points(1:(obj.Options.buffSize*2-2),:)];

                % Copy and update prevState trajectories
                obj.CurrState.len = obj.PrevState.len; 
                obj.CurrState.len(tracked) = obj.CurrState.len(tracked) + 1;
                obj.CurrState.points = points;
                obj.CurrState.lbls = obj.PrevState.lbls;
                obj.CurrState.trajIds = obj.PrevState.trajIds;
                obj.CurrState.trackno = obj.PrevState.trackno;

                if (obj.Options.extrads)
                    obj.CurrState.startFrame = obj.PrevState.startFrame;
                    obj.CurrState.endFrame   = obj.PrevState.endFrame;
                    obj.CurrState.endFrame(tracked) = obj.CurrState.frameNo;
                end                
                
                if (obj.Options.dropEnded)
                    obj.CurrState.len = obj.CurrState.len(tracked);
                    obj.CurrState.points = obj.CurrState.points(:,tracked);
                    obj.CurrState.lbls = obj.CurrState.lbls(tracked);
                    obj.CurrState.trajIds = obj.CurrState.trajIds(tracked);
                    obj.CurrState.trackno = obj.CurrState.trackno(tracked);
                    
                    if (obj.Options.extrads)
                        obj.CurrState.startFrame = obj.CurrState.startFrame(tracked);
                        obj.CurrState.endFrame   = obj.CurrState.endFrame(tracked);
                    end                                    
                end
            end

            % Detect new points in current frame and add them to set of points
            [~,ia] = setdiff(trackno, obj.PrevState.trackno);
            num_select = length(ia);
            new_points = [dpoints(:,ia); nan(2*(obj.Options.buffSize-1),num_select)];
            new_trackno = trackno(ia);
            
            % Update Datastructures
            obj.CurrState.len = [obj.CurrState.len ones(1,num_select)];
            obj.CurrState.points = [obj.CurrState.points new_points];
            obj.CurrState.trackno = [obj.CurrState.trackno new_trackno];            
            obj.CurrState.trajIds = [obj.CurrState.trajIds (obj.PrevState.maxTrajId+1:obj.PrevState.maxTrajId+size(new_points,2))];
            obj.CurrState.maxTrajId = obj.PrevState.maxTrajId + size(new_points,2);
            obj.CurrState.lbls = [obj.CurrState.lbls zeros(1, num_select)];

            % add by ethan 
            % Version that holds start and ending frames for memory trajectories.
            %newMemTraj = obj.CurrState.trajIds(obj.CurrState.len == options.smoothSize);
            %obj.CurrState.memTrajIds = [prevState.memTrajIds newMemTraj];
            
            % Version that holds start and ending frames for all trajectories.
            if (obj.Options.extrads)
                obj.CurrState.startFrame = [obj.CurrState.startFrame repmat(obj.CurrState.frameNo,1, size(new_points,2))];
                obj.CurrState.endFrame   = [obj.CurrState.endFrame repmat(obj.CurrState.frameNo,1, size(new_points,2))];
                %assert(length(obj.CurrState.startFrame) == obj.CurrState.maxTrajId && length(obj.CurrState.endFrame) == obj.CurrState.maxTrajId);
            end
        end    
    end
    
%     methods (Access = private, Static)         
%         function idx = selectSubset(sz, points, old_points, maxPoints)
%             divs = 20;
%             % Divide image into 10 by 10 grid. 
%             div = ceil(sz / divs);
%             coord(1,:) = floor(points(1,:)/ div(2)) + 1;
%             coord(2,:) = floor(points(2,:)/ div(1)) + 1;
% 
%             old_coord(1,:) = floor(old_points(1,:) / div(2)) + 1;
%             old_coord(2,:) = floor(old_points(2,:) / div(1)) + 1;
% 
%             ids = (coord(1,:)-1) * divs + coord(2,:);
%             old_ids = (old_coord(1,:)-1)*divs + old_coord(2,:);
%             budget = maxPoints - size(old_points,2);                 % Count of how many points we can add
%             old_count = histc(old_ids, 1:(divs*divs));              % Count existing points in each cell
%             %new_count = histc(ids, 1:(divs*divs));                 % Count new points in each cell
%             count_per_square = round(budget / (divs * divs));        % 
%             remaining_count = max(count_per_square - old_count,0);  
%             %budget_per_square = round(budget .* (1 - (old_count ./ size(old_points,2)))
% 
%             idx = [];
%             for i=find(remaining_count > 0)
%                 members = find(ids ==i);
%                 idx = [idx members(1:ceil(length(members)/remaining_count(i)):length(members))];
%             end
%         end         
%     end
end

