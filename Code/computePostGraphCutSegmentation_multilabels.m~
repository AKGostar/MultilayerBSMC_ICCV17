function [state] = computePostGraphCutSegmentation_multilabels(state, lmask, options) %by ethan
    dframe = double(state.frame);
    [m n ~] = size(dframe); 
    
    mask = zeros(size(lmask)); % return to 1,2,3
    layer_num = length(state.layers); 
    for i = 1:layer_num
        mask(lmask==state.layers(i).label) = i; 
    end 
    
    initial_labels = reshape(mask, [1,m*n]);  % for CLASS   
    initial_labels_toInput = initial_labels -1; % became 0,1,2
    
    
    %%%%%%%% prepare the data cost (UNARY)
    datacost = []; % (C X N) (1,0,1)
    for i = 1: layer_num
        datacost_term = ones(1, m*n);
        datacost_term(initial_labels == i) = 0; 
        datacost = [datacost; datacost_term]; 
    end
    
    %%%%%%%% prepare label cost (LABELCOST)
    labelcost = ones(layer_num); 
    for i = 1:layer_num
        labelcost(i, i) = 0; 
    end
    
    %%%%%%%% prepare edge weigh cost (PAIRWISE)

    hDiff = [dframe(:,1:n-1,:) - dframe(:,2:n,:) zeros(m,1,3)];
    vDiff = [dframe(1:m-1,:,:) - dframe(2:m,:,:); zeros(1,n,3)];
    %seDiff = [dframe(1:m-1,1:n-1,:) - dframe(2:m,2:n,:) zeros(m-1,1,3); zeros(1,n,3)];
    %neDiff = [zeros(1,n,3); dframe(2:m,1:n-1,:) - dframe(1:m-1,2:n,:) zeros(m-1,1,3)];
    halfInvSig = (1/(options.sigma_app)) * eye(3);
    hZ = halfInvSig * reshape(permute(hDiff, [3 1 2]), 3, m*n);
    vZ = halfInvSig * reshape(permute(vDiff, [3 1 2]), 3, m*n);
    %neZ = halfInvSig * reshape(permute(neDiff, [3 1 2]), 3, m*n);
    %seZ = halfInvSig * reshape(permute(seDiff, [3 1 2]), 3, m*n);
    hCue = reshape(exp(-0.5 * sum(hZ .* hZ)), m, n);
    vCue = reshape(exp(-0.5 * sum(vZ .* vZ)), m, n);
    %neCue = reshape(exp(-0.5 * sum(neZ .* neZ)), m,n);
    %seCue = reshape(exp(-0.5 * sum(seZ .* seZ)), m,n);     
    rows_store = []; 
    cols_store = [];
    v_store = []; 
    % prepare pairwise for hCue data 
    hCue = hCue(:, 1:n-1);% m * n-1
    i = 1:m; 
    i = repmat(i, n-1, 1); 
    i = reshape(i, [1, (n-1)*m]); 
    
    j = (1:n-1)';
    j = repmat(j, 1, m); 
    j = reshape(j, [1, (n-1)*m]); 
    
    rows = sub2ind([m,n], i, j);
    cols = sub2ind([m,n], i, j+1); 
    v = reshape(hCue', [1, m*(n-1)]); 
    rows_store = [rows_store, rows];
    cols_store = [cols_store, cols];
    v_store = [v_store, v]; 
    rows_store = [rows_store, cols];
    cols_store = [cols_store, rows];
    v_store = [v_store, v]; 
    
    % prepare pairwise for vCue data 
    vCue = vCue(1:m-1, :); % m-1 * n
    i = 1:m-1; 
    i = repmat(i, n, 1); 
    i = reshape(i, [1, n*(m-1)]); 
    
    j = (1:n)';
    j= repmat(j, 1, m-1);
    j = reshape(j, [1, n*(m-1)]); 
    
    rows = sub2ind([m,n], i, j);
    cols = sub2ind([m,n], i+1, j); 
    v = reshape(vCue', [1, n*(m-1)]); 
    rows_store = [rows_store, rows];
    cols_store = [cols_store, cols];
    v_store = [v_store, v]; 
    rows_store = [rows_store, cols];
    cols_store = [cols_store, rows];
    v_store = [v_store, v]; 
    
    sMatrix = sparse(rows_store, cols_store, v_store, m*n, m*n);  % N X N sparse matrix 
    
    if(layer_num > 2)
        EXPANSION = 1; %  0 == swap(2 lablels), 1 == expansion
    else
        EXPANSION = 0;
    end
    dinitial_labels = double(initial_labels_toInput);
    sdatacost = single(datacost);
    slabelcost = single(labelcost); 
   
% %      % use graph cut with multiple labels
% %     h = GCO_Create(m*n,label_num); 
% %     GCO_SetDataCost(h,sdatacost); 
% %     GCO_SetSmoothCost(h,slabelcost); 
% %     GCO_SetNeighbors(h,sMatrix); 
% %     if(label_num >2)
% %        GCO_Expansion(h);
% %     else
% %        GCO_Swap(h);
% %     end
% %     labels = GCO_GetLabeling(h);
% %     [E D S] = GCO_ComputeEnergy(h);
% %     GCO_Delete(h); 

    % use graph cut with multiple labels
    
    [labels energy energy_after] = GCMex(dinitial_labels, options.datacost_lambda *sdatacost, ...
        options.pairwise_lambda * sMatrix, options.labelcost_lambda * slabelcost, EXPANSION);
  
    mask = reshape(labels, [m , n]);
    mask = mask + 1; 
   
    label_mask = zeros(size(mask));     
    for i = 1: layer_num
        mask_term = zeros(size(mask)); 
        mask_term(mask==i) = 1; 
        state.layers(i).mask = mask_term; 
        label_mask(mask==i) = state.layers(i).label; 
    end
    state.lmask = label_mask; 
end